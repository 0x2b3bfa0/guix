This patch is required to fix a test failure when python-dateutil version
2.5.2 or later is used.  It is derived from the following commits:

80ef4e06526b9b60cf24268454c9456585a790a3
845ff974af6f7c3b3067cce8a7149b771c2be87

diff --git a/pandas/tseries/tests/test_tslib.py b/pandas/tseries/tests/test_tslib.py
index f0d5bf7..863bc6f 100644
--- a/pandas/tseries/tests/test_tslib.py
+++ b/pandas/tseries/tests/test_tslib.py
@@ -474,6 +474,11 @@ def test_does_not_convert_mixed_integer(self):
                 good_date_string))
 
     def test_parsers(self):
+
+        # https://github.com/dateutil/dateutil/issues/217
+        import dateutil
+        yearfirst = dateutil.__version__ >= LooseVersion('2.5.0')
+
         cases = {'2011-01-01': datetime.datetime(2011, 1, 1),
                  '2Q2005': datetime.datetime(2005, 4, 1),
                  '2Q05': datetime.datetime(2005, 4, 1),
@@ -527,20 +532,26 @@ def test_parsers(self):
                  }
 
         for date_str, expected in compat.iteritems(cases):
-            result1, _, _ = tools.parse_time_string(date_str)
-            result2 = to_datetime(date_str)
-            result3 = to_datetime([date_str])
-            result4 = to_datetime(np.array([date_str], dtype=object))
-            result5 = Timestamp(date_str)
-            result6 = DatetimeIndex([date_str])[0]
-            result7 = date_range(date_str, freq='S', periods=1)
+            result1, _, _ = tools.parse_time_string(date_str,
+                                                    yearfirst=yearfirst)
+            result2 = to_datetime(date_str, yearfirst=yearfirst)
+            result3 = to_datetime([date_str], yearfirst=yearfirst)
+            result4 = to_datetime(np.array([date_str], dtype=object),
+                                  yearfirst=yearfirst)
+            result6 = DatetimeIndex([date_str], yearfirst=yearfirst)[0]
             self.assertEqual(result1, expected)
             self.assertEqual(result2, expected)
             self.assertEqual(result3, expected)
             self.assertEqual(result4, expected)
-            self.assertEqual(result5, expected)
             self.assertEqual(result6, expected)
-            self.assertEqual(result7, expected)
+
+            # these really need to have yearfist, but we don't support
+            if not yearfirst:
+                result5 = Timestamp(date_str)
+                self.assertEqual(result5, expected)
+                result7 = date_range(date_str, freq='S', periods=1,
+                                     yearfirst=yearfirst)
+                self.assertEqual(result7, expected)
 
         # NaT
         result1, _, _ = tools.parse_time_string('NaT')
@@ -589,23 +589,62 @@ def test_parsers_quarter_invalid(self):
             self.assertRaises(ValueError, tools.parse_time_string, case)
 
     def test_parsers_dayfirst_yearfirst(self):
+
+        # https://github.com/dateutil/dateutil/issues/217
+        # this issue was closed
+        import dateutil
+        is_compat_version = dateutil.__version__ >= LooseVersion('2.5.2')
+        if is_compat_version:
+            dayfirst_yearfirst1 = datetime.datetime(2010, 12, 11)
+            dayfirst_yearfirst2 = datetime.datetime(2020, 12, 21)
+        else:
+            dayfirst_yearfirst1 = datetime.datetime(2010, 11, 12)
+            dayfirst_yearfirst2 = datetime.datetime(2020, 12, 21)
+
         # str : dayfirst, yearfirst, expected
-        cases = {'10-11-12': [(False, False, datetime.datetime(2012, 10, 11)),
-                              (True, False, datetime.datetime(2012, 11, 10)),
-                              (False, True, datetime.datetime(2010, 11, 12)),
-                              (True, True, datetime.datetime(2010, 11, 12))],
-                 '20/12/21': [(False, False, datetime.datetime(2021, 12, 20)),
-                              (True, False, datetime.datetime(2021, 12, 20)),
-                              (False, True, datetime.datetime(2020, 12, 21)),
-                              (True, True, datetime.datetime(2020, 12, 21))]}
+        cases = {'10-11-12': [(False, False, False,
+                               datetime.datetime(2012, 10, 11)),
+                              (True, False, False,
+                               datetime.datetime(2012, 11, 10)),
+                              (False, True, False,
+                               datetime.datetime(2010, 11, 12)),
+                              (True, True, False, dayfirst_yearfirst1)],
+                 '20/12/21': [(False, False, False,
+                               datetime.datetime(2021, 12, 20)),
+                              (True, False, False,
+                               datetime.datetime(2021, 12, 20)),
+                              (False, True, False,
+                               datetime.datetime(2020, 12, 21)),
+                              (True, True, True, dayfirst_yearfirst2)]}
 
         tm._skip_if_no_dateutil()
         from dateutil.parser import parse
         for date_str, values in compat.iteritems(cases):
-            for dayfirst, yearfirst, expected in values:
-                result1, _, _ = tools.parse_time_string(date_str,
-                                                        dayfirst=dayfirst,
-                                                        yearfirst=yearfirst)
+            for dayfirst, yearfirst, is_compat, expected in values:
+
+                f = lambda x: tools.parse_time_string(x,
+                                                      dayfirst=dayfirst,
+                                                      yearfirst=yearfirst)
+
+                # we now have an invalid parse
+                if is_compat and is_compat_version:
+                    self.assertRaises(tslib.DateParseError, f, date_str)
+
+                    def f(date_str):
+                        return to_datetime(date_str, dayfirst=dayfirst,
+                                           yearfirst=yearfirst)
+
+                    self.assertRaises(ValueError, f, date_str)
+
+                    def f(date_str):
+                        return DatetimeIndex([date_str], dayfirst=dayfirst,
+                                             yearfirst=yearfirst)[0]
+
+                    self.assertRaises(ValueError, f, date_str)
+
+                    continue
+
+                result1, _, _ = f(date_str)
 
                 result2 = to_datetime(date_str, dayfirst=dayfirst,
                                       yearfirst=yearfirst)
@@ -614,7 +653,6 @@ def test_parsers_dayfirst_yearfirst(self):
                                         yearfirst=yearfirst)[0]
 
                 # Timestamp doesn't support dayfirst and yearfirst
-
                 self.assertEqual(result1, expected)
                 self.assertEqual(result2, expected)
                 self.assertEqual(result3, expected)
