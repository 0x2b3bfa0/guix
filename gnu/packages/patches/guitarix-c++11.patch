Work around a C++11 incompatibility when compiling the gperf-generated
'jsonrpc_methods.cc' with -std=c++11:

  default/src/gx_head/engine/jsonrpc_methods.cc: In function ‘const CmdConnection::methodnames* in_word_set(const char*, unsigned int)’:
  default/src/gx_head/engine/jsonrpc_methods.cc:211:26: error: reference to ‘hash’ is ambiguous
	 register int key = hash (str, len);
			    ^
The solution is to run 'gperf -L C++' so that it generates code with
appropriate C++ name-spacing to avoid the ambiguity.

--- guitarix-0.33.0/tools/make_jsonrpc_methods	2015-10-31 12:45:52.756587435 +0100
+++ guitarix-0.33.0/tools/make_jsonrpc_methods	2015-10-31 12:47:02.801103366 +0100
@@ -14,7 +14,7 @@ def add_enums(template_name, hashtable_n
     hashtable = open(hashtable_name, "w")
     hashtable.write(headline)
     hashtable.flush()
-    gperf = Popen(gperf_program, stdin=PIPE, stdout=hashtable)
+    gperf = Popen([gperf_program, "-L", "C++"], stdin=PIPE, stdout=hashtable)
     enumlist = []
     section = 0
     in_comment = False

--- guitarix-0.33.0/src/gx_head/engine/jsonrpc.cpp	2015-10-31 12:50:33.934647842 +0100
+++ guitarix-0.33.0/src/gx_head/engine/jsonrpc.cpp	2015-10-31 12:50:51.238773730 +0100
@@ -1171,7 +1171,7 @@ bool CmdConnection::request(gx_system::J
 	}
     }
     jp.next(gx_system::JsonParser::end_object);
-    const methodnames *p = in_word_set(method.c_str(), method.size());
+    const methodnames *p = Perfect_Hash::in_word_set(method.c_str(), method.size());
     if (!p) {
 	throw RpcError(-32601, Glib::ustring::compose("Method not found -- '%1'", method));
     }


The following part is adapted from an upstream patch for the new libsigc++.

commit 001aa683814a7bf4537882c7c3acf1dafd851cd5
Author: Hermann Meyer <brummer-@web.de>
Date:   Sat Oct 31 09:33:16 2015 +0100

     * fix libsigc++ removes sigc::group

diff --git a/src/gx_head/gui/avahi_discover.cpp b/src/gx_head/gui/avahi_discover.cpp
index c49746e..88993c2 100644
--- a/src/gx_head/gui/avahi_discover.cpp
+++ b/src/gx_head/gui/avahi_discover.cpp
@@ -193,7 +193,9 @@ SelectInstance::SelectInstance(gx_system::CmdlineOptions& options, Gtk::Window *
     win->signal_response().connect(sigc::mem_fun(this, &SelectInstance::on_response));
     bld->get_widget("treeview", view);
     view->signal_row_activated().connect(
-	sigc::group(sigc::mem_fun(win, &Gtk::Dialog::response), 1));
+    sigc::mem_fun(this,&SelectInstance::on_row));
+    //view->signal_row_activated().connect(
+	//sigc::group(sigc::mem_fun(win, &Gtk::Dialog::response), 1));
     view->set_model(Gtk::ListStore::create(cols));
     view->get_selection()->set_mode(Gtk::SELECTION_BROWSE);
     view->get_selection()->signal_changed().connect(
@@ -242,6 +244,10 @@ void SelectInstance::on_avahi_changed() {
     }
 }
 
+void SelectInstance::on_row(const Gtk::TreePath& path, Gtk::TreeViewColumn* column) {
+	on_response(1);
+}
+	
 void SelectInstance::on_response(int response_id) {
     if (response_id == 1) {
 	Gtk::TreeIter i = view->get_selection()->get_selected();
diff --git a/src/gx_head/gui/gx_main.cpp b/src/gx_head/gui/gx_main.cpp
index d1ad329..a207aa6 100644
--- a/src/gx_head/gui/gx_main.cpp
+++ b/src/gx_head/gui/gx_main.cpp
@@ -281,8 +281,10 @@ void ErrorPopup::show_msg() {
     align->set_padding(50,20,0,10);
     Gtk::VBox *vbox = dynamic_cast<Gtk::VBox *>(dialog->get_child());
     vbox->set_redraw_on_allocate(true);
-    vbox->signal_expose_event().connect(
-	sigc::group(&gx_cairo::error_box_expose,GTK_WIDGET(vbox->gobj()),sigc::_1,(void*)0),false);
+    g_signal_connect(GTK_WIDGET(vbox->gobj()), "expose-event",
+                     G_CALLBACK(gx_cairo::error_box_expose), NULL);
+   // vbox->signal_expose_event().connect(
+	//sigc::group(&gx_cairo::error_box_expose,GTK_WIDGET(vbox->gobj()),sigc::_1,(void*)0),false);
     dialog->set_title(_("GUITARIX ERROR"));
     dialog->signal_response().connect(
 	sigc::mem_fun(*this, &ErrorPopup::on_response));
@@ -306,9 +308,11 @@ GxSplashBox::GxSplashBox()
     : Gtk::Window(Gtk::WINDOW_POPUP) {
     set_redraw_on_allocate(true);
     set_app_paintable();
-    signal_expose_event().connect(
-        sigc::group(&gx_cairo::splash_expose, GTK_WIDGET(gobj()),
-		    sigc::_1, (void*)0), false);
+    g_signal_connect(GTK_WIDGET(gobj()), "expose-event",
+                     G_CALLBACK(gx_cairo::splash_expose), NULL);
+    //signal_expose_event().connect(
+    //    sigc::group(&gx_cairo::splash_expose, GTK_WIDGET(gobj()),
+	//	    sigc::_1, (void*)0), false);
     set_decorated(false);
     set_type_hint(Gdk::WINDOW_TYPE_HINT_SPLASHSCREEN);
     set_position(Gtk::WIN_POS_CENTER );
diff --git a/src/gx_head/gui/gx_main_window.cpp b/src/gx_head/gui/gx_main_window.cpp
index 23c9ae6..eb0e201 100644
--- a/src/gx_head/gui/gx_main_window.cpp
+++ b/src/gx_head/gui/gx_main_window.cpp
@@ -1303,6 +1303,23 @@ void MainWindow::on_log_activate() {
         fLoggingWindow.hide();
     }
 }
+// show loggingbox
+bool MainWindow::on_log_activated(GdkEventButton* ev) {
+    if (ev->type == GDK_BUTTON_PRESS && ev->button == 1) {
+    if (!actions.loggingbox->get_active()) {
+		actions.loggingbox->set_active(true);
+        gint rxorg, ryorg;
+        window->get_position(rxorg, ryorg);
+        fLoggingWindow.move(rxorg+5, ryorg+272);
+        fLoggingWindow.show_all();
+        on_msg_level_changed();
+    } else {
+        fLoggingWindow.hide();
+        actions.loggingbox->set_active(false);
+    }
+	}
+    return true;
+}
 
 void MainWindow::on_engine_toggled() {
     gx_engine::GxEngineState s;
@@ -2119,6 +2136,14 @@ bool MainWindow::on_toggle_mute(GdkEventButton* ev) {
     return true;
 }
 
+bool MainWindow::on_jackserverconnection(GdkEventButton* ev) {
+    if (ev->type == GDK_BUTTON_PRESS && ev->button == 1) {
+    bool v = actions.jackserverconnection->get_active();
+    actions.jackserverconnection->set_active(!v);
+    }
+    return true;
+}
+
 void MainWindow::on_msg_level_changed() {
     switch (fLoggingWindow.get_unseen_msg_level()) {
     case GxLogger::kWarning: logstate_image->set(pixbuf_log_yellow); break;
@@ -2683,12 +2708,14 @@ MainWindow::MainWindow(gx_engine::GxMachineBase& machine_, gx_system::CmdlineOpt
     */
     if (jack) {
 	jackd_image->set(pixbuf_jack_disconnected);
-	jackd_image->get_parent()->signal_button_press_event().connect(
-	    sigc::bind_return(
-		sigc::group(
-		    sigc::ptr_fun(toggle_action),
-		    actions.jackserverconnection),
-		true));
+    jackd_image->get_parent()->signal_button_press_event().connect(
+	sigc::mem_fun(*this, &MainWindow::on_jackserverconnection));
+	//jackd_image->get_parent()->signal_button_press_event().connect(
+	//    sigc::bind_return(
+	//	sigc::group(
+	//	    sigc::ptr_fun(toggle_action),
+	//	    actions.jackserverconnection),
+	//	true));
     } else {
 	jackd_image->hide();
     }
@@ -2823,11 +2850,14 @@ MainWindow::MainWindow(gx_engine::GxMachineBase& machine_, gx_system::CmdlineOpt
 	    false));
     on_msg_level_changed();
     logstate_image->get_parent()->signal_button_press_event().connect(
-	sigc::bind_return(
-	    sigc::group(
-		sigc::ptr_fun(toggle_action),
-		actions.loggingbox),
-	    true));
+    sigc::mem_fun(*this, &MainWindow::on_log_activated));
+    
+    //logstate_image->get_parent()->signal_button_press_event().connect(
+	//sigc::bind_return(
+	//    sigc::group(
+	//	sigc::ptr_fun(toggle_action),
+	//	actions.loggingbox),
+	//    true));
 
     /*
     ** load plugin definitions into plugin_dict, add to effects_toolpalette
diff --git a/src/gx_head/gui/gx_portmap.cpp b/src/gx_head/gui/gx_portmap.cpp
index d8a6ae6..e711ee7 100644
--- a/src/gx_head/gui/gx_portmap.cpp
+++ b/src/gx_head/gui/gx_portmap.cpp
@@ -578,12 +578,16 @@ PortMapWindow::PortMapWindow(Glib::RefPtr<gx_gui::GxBuilder> bld, gx_jack::GxJac
     b->set_name("rack_button");
     Gtk::VBox *vbox1;
     bld->find_widget("dialog-vbox1", vbox1);
-    vbox1->signal_expose_event().connect(
-	sigc::group(&gx_cairo::rectangle_skin_color_expose,GTK_WIDGET(vbox1->gobj()),sigc::_1,(void*)0),false);
+    g_signal_connect(GTK_WIDGET(vbox1->gobj()), "expose-event",
+                     G_CALLBACK(gx_cairo::rectangle_skin_color_expose), NULL);
+   // vbox1->signal_expose_event().connect(
+	//sigc::group(&gx_cairo::rectangle_skin_color_expose,GTK_WIDGET(vbox1->gobj()),sigc::_1,(void*)0),false);
     Gtk::VBox *vbox2;
     bld->find_widget("dialog-vbox2", vbox2);
-    vbox2->signal_expose_event().connect(
-	sigc::group(&gx_cairo::rectangle_skin_color_expose,GTK_WIDGET(vbox2->gobj()),sigc::_1,(void*)0),false);
+    g_signal_connect(GTK_WIDGET(vbox2->gobj()), "expose-event",
+                     G_CALLBACK(gx_cairo::rectangle_skin_color_expose), NULL);
+  //  vbox2->signal_expose_event().connect(
+//	sigc::group(&gx_cairo::rectangle_skin_color_expose,GTK_WIDGET(vbox2->gobj()),sigc::_1,(void*)0),false);
     vbox1->set_redraw_on_allocate(true);
     vbox2->set_redraw_on_allocate(true);
     for (int i = 0; i < number_of_ports; ++i) {
diff --git a/src/headers/avahi_discover.h b/src/headers/avahi_discover.h
index 5af5949..b6f523a 100644
--- a/src/headers/avahi_discover.h
+++ b/src/headers/avahi_discover.h
@@ -91,6 +91,7 @@ private:
     } cols;
 private:
     void on_response(int response_id);
+    void on_row(const Gtk::TreePath& path, Gtk::TreeViewColumn* column);
     void on_avahi_changed();
     void on_selection_changed();
 public:
diff --git a/src/headers/gx_main_window.h b/src/headers/gx_main_window.h
index 3b54285..e7c02ce 100644
--- a/src/headers/gx_main_window.h
+++ b/src/headers/gx_main_window.h
@@ -720,6 +720,7 @@ private:
     void on_load_ladspa();
     void delete_select_jack_control();
     void on_log_activate();
+    bool on_log_activated(GdkEventButton* ev);
     void do_program_change(int pgm);
     void on_engine_toggled();
     void on_engine_state_change(gx_engine::GxEngineState state);
@@ -728,6 +729,7 @@ private:
     void setup_tuner_temperament(Gxw::RackTuner& tuner);
     void setup_tuner(Gxw::RackTuner& tuner);
     bool on_toggle_mute(GdkEventButton* ev);
+    bool on_jackserverconnection(GdkEventButton* ev);
     void on_msg_level_changed();
     void on_ampdetail_switch(bool compress, bool setparam);
     void on_show_oscilloscope(bool v);

The following is adapted from this upstream patch, which does a whole
bunch of unrelated things.

commit 44ab541a5a846c0b3832f4225d1ae92183d55550
Author: Hermann Meyer <brummer-@web.de>
Date:   Fri Oct 30 08:47:42 2015 +0100

     * add 53 tet tuner option
     * add online preset download widget (requiers libwebkit-1.0
     * fix bug #27
     * fix build fail with c++11 system libs (make c++11 default)

--- a/src/LV2/gx_amp.lv2/gxamp_gui.cpp
+++ b/src/LV2/gx_amp.lv2/gxamp_gui.cpp
@@ -124,7 +124,7 @@ void GXPluginGUI::set_skin()
   gtk_rc_parse_string (toparse.c_str());
 }
 
-inline std::string to_string(long long _Val)
+inline std::string t_string(long long _Val)
 {   // convert int to string
         char _Buf[128];
         sprintf(_Buf, "%lld", _Val);
@@ -136,7 +136,7 @@ void GXPluginGUI::set_plug_name()
   // Here the plugin should have different name for different amp.....
   addKnob = "";
   plugskin = "amp21.png";
-  plug_name = "GUITARIXLV2" + to_string(reinterpret_cast<long long>(this));
+  plug_name = "GUITARIXLV2" + t_string(reinterpret_cast<long long>(this));
   //fprintf(stderr,"%s",plug_name.c_str());
 }
 
diff --git a/src/LV2/gx_amp_stereo.lv2/gxamp_stereo_gui.cpp b/src/LV2/gx_amp_stereo.lv2/gxamp_stereo_gui.cpp
index d5947ee..edc1caa 100644
--- a/src/LV2/gx_amp_stereo.lv2/gxamp_stereo_gui.cpp
+++ b/src/LV2/gx_amp_stereo.lv2/gxamp_stereo_gui.cpp
@@ -124,7 +124,7 @@ void GXPluginGUI::set_skin()
   gtk_rc_parse_string (toparse.c_str());
 }
 
-inline std::string to_string(long long _Val)
+inline std::string t_string(long long _Val)
 {   // convert int to string
         char _Buf[128];
         sprintf(_Buf, "%lld", _Val);
@@ -135,7 +135,7 @@ void GXPluginGUI::set_plug_name()
 {
   addKnob = "";
   plugskin = "amp21.png";
-  plug_name = "GUITARIXLV2" + to_string(reinterpret_cast<long long>(this));
+  plug_name = "GUITARIXLV2" + t_string(reinterpret_cast<long long>(this));
 }
 
 GtkWidget* GXPluginGUI::make_gui()
