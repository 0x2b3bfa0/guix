commit d74bdb4589ad714e2a45e282974db075de2be673
Author: Randell Jesup <rjesup@jesup.org>
Date:   Wed Nov 12 22:59:53 2014 -0500

    Bug 1080312 - Update iteration code from upstream. r=jesup, a=abillings

	Modified   netwerk/sctp/src/moz.build
diff --git a/netwerk/sctp/src/moz.build b/netwerk/sctp/src/moz.build
index 1901a41..82103b9 100644
--- a/netwerk/sctp/src/moz.build
+++ b/netwerk/sctp/src/moz.build
@@ -31,7 +31,6 @@ SOURCES += [
     'user_environment.c',
     'user_mbuf.c',
     'user_recv_thread.c',
-    'user_sctp_timer_iterate.c',
     'user_socket.c',
 ]
 
	Modified   netwerk/sctp/src/netinet/sctp_callout.c
diff --git a/netwerk/sctp/src/netinet/sctp_callout.c b/netwerk/sctp/src/netinet/sctp_callout.c
index 67b7566..e8ac77f 100755
--- a/netwerk/sctp/src/netinet/sctp_callout.c
+++ b/netwerk/sctp/src/netinet/sctp_callout.c
@@ -30,9 +30,27 @@
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#if defined(__Userspace__)
+#include <sys/types.h>
+#if !defined (__Userspace_os_Windows)
+#include <sys/wait.h>
+#include <unistd.h>
+#include <pthread.h>
+#endif
+#if defined(__Userspace_os_NaCl)
+#include <sys/select.h>
+#endif
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <netinet/sctp_sysctl.h>
+#include <netinet/sctp_pcb.h>
+#else
 #include <netinet/sctp_os.h>
 #include <netinet/sctp_callout.h>
 #include <netinet/sctp_pcb.h>
+#endif
 
 /*
  * Callout/Timer routines for OS that doesn't have them
@@ -117,24 +135,16 @@ sctp_os_timer_stop(sctp_os_timer_t *c)
 	return (1);
 }
 
-#if defined(__APPLE__)
-/*
- * For __APPLE__, use a single main timer at a faster resolution than
- * fastim.  The timer just calls this existing callout infrastructure.
- */
-#endif
-void
-sctp_timeout(void *arg SCTP_UNUSED)
+static void
+sctp_handle_tick(int delta)
 {
 	sctp_os_timer_t *c;
 	void (*c_func)(void *);
 	void *c_arg;
 
 	SCTP_TIMERQ_LOCK();
-#if defined(__APPLE__)
 	/* update our tick count */
-	ticks += SCTP_BASE_VAR(sctp_main_timer_ticks);
-#endif
+	ticks += delta;
 	c = TAILQ_FIRST(&SCTP_BASE_INFO(callqueue));
 	while (c) {
 		if (c->c_time <= ticks) {
@@ -155,9 +165,60 @@ sctp_timeout(void *arg SCTP_UNUSED)
 	}
 	sctp_os_timer_next = NULL;
 	SCTP_TIMERQ_UNLOCK();
+}
 
 #if defined(__APPLE__)
-	/* restart the main timer */
+void
+sctp_timeout(void *arg SCTP_UNUSED)
+{
+	sctp_handle_tick(SCTP_BASE_VAR(sctp_main_timer_ticks));
 	sctp_start_main_timer();
+}
 #endif
+
+#if defined(__Userspace__)
+#define TIMEOUT_INTERVAL 10
+
+void *
+user_sctp_timer_iterate(void *arg)
+{
+	for (;;) {
+#if defined (__Userspace_os_Windows)
+		Sleep(TIMEOUT_INTERVAL);
+#else
+		struct timeval timeout;
+
+		timeout.tv_sec  = 0;
+		timeout.tv_usec = 1000 * TIMEOUT_INTERVAL;
+		select(0, NULL, NULL, NULL, &timeout);
+#endif
+		if (SCTP_BASE_VAR(timer_thread_should_exit)) {
+			break;
+		}
+		sctp_handle_tick(MSEC_TO_TICKS(TIMEOUT_INTERVAL));
+	}
+	return (NULL);
 }
+
+void
+sctp_start_timer(void)
+{
+	/*
+	 * No need to do SCTP_TIMERQ_LOCK_INIT();
+	 * here, it is being done in sctp_pcb_init()
+	 */
+#if defined (__Userspace_os_Windows)
+	if ((SCTP_BASE_VAR(timer_thread) = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)user_sctp_timer_iterate, NULL, 0, NULL)) == NULL) {
+		SCTP_PRINTF("ERROR; Creating ithread failed\n");
+	}
+#else
+	int rc;
+
+	rc = pthread_create(&SCTP_BASE_VAR(timer_thread), NULL, user_sctp_timer_iterate, NULL);
+	if (rc) {
+		SCTP_PRINTF("ERROR; return code from pthread_create() is %d\n", rc);
+	}
+#endif
+}
+
+#endif
	Modified   netwerk/sctp/src/netinet/sctp_callout.h
diff --git a/netwerk/sctp/src/netinet/sctp_callout.h b/netwerk/sctp/src/netinet/sctp_callout.h
index 2782945..c53c5a4 100755
--- a/netwerk/sctp/src/netinet/sctp_callout.h
+++ b/netwerk/sctp/src/netinet/sctp_callout.h
@@ -64,7 +64,6 @@ __FBSDID("$FreeBSD$");
 #endif
 
 extern int ticks;
-extern void sctp_start_timer();
 #endif
 
 TAILQ_HEAD(calloutlist, sctp_callout);
@@ -94,6 +93,11 @@ int sctp_os_timer_stop(sctp_os_timer_t *);
 #define	SCTP_OS_TIMER_ACTIVE(tmr) ((tmr)->c_flags & SCTP_CALLOUT_ACTIVE)
 #define	SCTP_OS_TIMER_DEACTIVATE(tmr) ((tmr)->c_flags &= ~SCTP_CALLOUT_ACTIVE)
 
+#if defined(__Userspace__)
+void sctp_start_timer(void);
+#endif
+#if defined(__APPLE__)
 void sctp_timeout(void *);
+#endif
 
 #endif
	Modified   netwerk/sctp/src/netinet/sctp_usrreq.c
diff --git a/netwerk/sctp/src/netinet/sctp_usrreq.c b/netwerk/sctp/src/netinet/sctp_usrreq.c
index d4115ad..c17ea04 100755
--- a/netwerk/sctp/src/netinet/sctp_usrreq.c
+++ b/netwerk/sctp/src/netinet/sctp_usrreq.c
@@ -56,6 +56,9 @@ __FBSDID("$FreeBSD: head/sys/netinet/sctp_usrreq.c 259943 2013-12-27 13:07:00Z t
 #include <netinet/sctp_timer.h>
 #include <netinet/sctp_auth.h>
 #include <netinet/sctp_bsd_addr.h>
+#if defined(__Userspace__)
+#include <netinet/sctp_callout.h>
+#endif
 #if !defined(__Userspace_os_Windows)
 #include <netinet/udp.h>
 #endif
	Deleted    netwerk/sctp/src/user_sctp_timer_iterate.c
diff --git a/netwerk/sctp/src/user_sctp_timer_iterate.c b/netwerk/sctp/src/user_sctp_timer_iterate.c
deleted file mode 100755
index 0a9dbce..0000000
--- a/netwerk/sctp/src/user_sctp_timer_iterate.c
+++ /dev/null
@@ -1,119 +0,0 @@
-/*-
- * Copyright (c) 2012 Michael Tuexen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- */
-
-#include <sys/types.h>
-#if !defined (__Userspace_os_Windows)
-#include <sys/wait.h>
-#include <unistd.h>
-#include <pthread.h>
-#endif
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <errno.h>
-#include <netinet/sctp_pcb.h>
-#include <netinet/sctp_sysctl.h>
-#include "netinet/sctp_callout.h"
-
-/* This is the polling time of callqueue in milliseconds
- * 10ms seems to work well. 1ms was giving erratic behavior
- */
-#define TIMEOUT_INTERVAL 10
-
-extern int ticks;
-
-void *
-user_sctp_timer_iterate(void *arg)
-{
-	sctp_os_timer_t *c;
-	void (*c_func)(void *);
-	void *c_arg;
-	sctp_os_timer_t *sctp_os_timer_next;
-	/*
-	 * The MSEC_TO_TICKS conversion depends on hz. The to_ticks in
-	 * sctp_os_timer_start also depends on hz. E.g. if hz=1000 then
-	 * for multiple INIT the to_ticks is 2000, 4000, 8000, 16000, 32000, 60000
-	 * and further to_ticks level off at 60000 i.e. 60 seconds.
-	 * If hz=100 then for multiple INIT the to_ticks are 200, 400, 800 and so-on.
-	 */
-	for (;;) {
-#if defined (__Userspace_os_Windows)
-		Sleep(TIMEOUT_INTERVAL);
-#else
-		struct timeval timeout;
-
-		timeout.tv_sec  = 0;
-		timeout.tv_usec = 1000 * TIMEOUT_INTERVAL;
-		select(0, NULL, NULL, NULL, &timeout);
-#endif
-		if (SCTP_BASE_VAR(timer_thread_should_exit)) {
-			break;
-		}
-		SCTP_TIMERQ_LOCK();
-		/* update our tick count */
-		ticks += MSEC_TO_TICKS(TIMEOUT_INTERVAL);
-		c = TAILQ_FIRST(&SCTP_BASE_INFO(callqueue));
-		while (c) {
-			if (c->c_time <= ticks) {
-				sctp_os_timer_next = TAILQ_NEXT(c, tqe);
-				TAILQ_REMOVE(&SCTP_BASE_INFO(callqueue), c, tqe);
-				c_func = c->c_func;
-				c_arg = c->c_arg;
-				c->c_flags &= ~SCTP_CALLOUT_PENDING;
-				SCTP_TIMERQ_UNLOCK();
-				c_func(c_arg);
-				SCTP_TIMERQ_LOCK();
-				c = sctp_os_timer_next;
-			} else {
-				c = TAILQ_NEXT(c, tqe);
-			}
-		}
-		SCTP_TIMERQ_UNLOCK();
-	}
-	return (NULL);
-}
-
-void
-sctp_start_timer(void)
-{
-	/*
-	 * No need to do SCTP_TIMERQ_LOCK_INIT();
-	 * here, it is being done in sctp_pcb_init()
-	 */
-#if defined (__Userspace_os_Windows)
-	if ((SCTP_BASE_VAR(timer_thread) = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)user_sctp_timer_iterate, NULL, 0, NULL)) == NULL) {
-		SCTP_PRINTF("ERROR; Creating ithread failed\n");
-	}
-#else
-	int rc;
-
-	rc = pthread_create(&SCTP_BASE_VAR(timer_thread), NULL, user_sctp_timer_iterate, NULL);
-	if (rc) {
-		SCTP_PRINTF("ERROR; return code from pthread_create() is %d\n", rc);
-	}
-#endif
-}
