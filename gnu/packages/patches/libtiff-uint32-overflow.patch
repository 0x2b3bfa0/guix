Fix some buffer overflows:

http://seclists.org/oss-sec/2016/q4/
http://bugzilla.maptools.org/show_bug.cgi?id=2592

2016-11-11 Even Rouault <even.rouault at spatialys.com>

        * tools/tiffcrop.c: fix multiple uint32 overflows in
        writeBufferToSeparateStrips(), writeBufferToContigTiles() and
        writeBufferToSeparateTiles() that could cause heap buffer
overflows.
        Reported by Henri Salo from Nixu Corporation.
        Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2592


/cvs/maptools/cvsroot/libtiff/ChangeLog,v  <--  ChangeLog
new revision: 1.1152; previous revision: 1.1151
/cvs/maptools/cvsroot/libtiff/tools/tiffcrop.c,v  <--  tools/tiffcrop.c
new revision: 1.43; previous revision: 1.42

===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/tools/tiffcrop.c,v
retrieving revision 1.42
retrieving revision 1.43
diff -u -r1.42 -r1.43
--- libtiff/tools/tiffcrop.c	14 Oct 2016 19:13:20 -0000	1.42
+++ libtiff/tools/tiffcrop.c	11 Nov 2016 19:33:06 -0000	1.43
@@ -148,6 +148,8 @@
 #define PATH_MAX 1024
 #endif
 
+#define TIFF_UINT32_MAX     0xFFFFFFFFU
+
 #ifndef streq
 #define	streq(a,b)	(strcmp((a),(b)) == 0)
 #endif
@@ -1164,7 +1166,24 @@
   (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
   (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
   bytes_per_sample = (bps + 7) / 8;
-  rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */
+  if( width == 0 ||
+      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / width ||
+      bps * spp * width > TIFF_UINT32_MAX - 7U )
+  {
+      TIFFError(TIFFFileName(out),
+            "Error, uint32 overflow when computing (bps * spp * width) + 7");
+      return 1;
+  }
+  rowsize = ((bps * spp * width) + 7U) / 8; /* source has interleaved samples */
+  if( bytes_per_sample == 0 ||
+      rowsperstrip > TIFF_UINT32_MAX / bytes_per_sample ||
+      rowsperstrip * bytes_per_sample > TIFF_UINT32_MAX / (width + 1) )
+  {
+      TIFFError(TIFFFileName(out),
+                "Error, uint32 overflow when computing rowsperstrip * "
+                "bytes_per_sample * (width + 1)");
+      return 1;
+  }
   rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); 
 
   obuf = _TIFFmalloc (rowstripsize);
@@ -1251,11 +1270,19 @@
     }
     }
 
+  if( imagewidth == 0 ||
+      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||
+      bps * spp * imagewidth > TIFF_UINT32_MAX - 7U )
+  {
+      TIFFError(TIFFFileName(out),
+            "Error, uint32 overflow when computing (imagewidth * bps * spp) + 7");
+      return 1;
+  }
+  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;
+
   tilebuf = _TIFFmalloc(tile_buffsize);
   if (tilebuf == 0)
     return 1;
-
-  src_rowsize = ((imagewidth * spp * bps) + 7) / 8;
   for (row = 0; row < imagelength; row += tl)
     {
     nrow = (row + tl > imagelength) ? imagelength - row : tl;
@@ -1315,7 +1342,16 @@
   TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
   TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
   TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
-  src_rowsize = ((imagewidth * spp * bps) + 7) / 8;
+
+  if( imagewidth == 0 ||
+      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||
+      bps * spp * imagewidth > TIFF_UINT32_MAX - 7 )
+  {
+      TIFFError(TIFFFileName(out),
+            "Error, uint32 overflow when computing (imagewidth * bps * spp) + 7");
+      return 1;
+  }
+  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;
          
   for (row = 0; row < imagelength; row += tl)
     {
